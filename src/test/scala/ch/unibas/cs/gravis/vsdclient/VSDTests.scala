/*
* Copyright 2015 University of Basel, Graphics and Vision Research Group
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/

package ch.unibas.cs.gravis.vsdconnect

import java.io.File

import ch.unibas.cs.gravis.vsdclient._
import org.scalatest.concurrent.ScalaFutures
import org.scalatest.time.{Minutes, Span}
import org.scalatest.{FunSpec, _}
import spray.can.Http.ConnectionException

import scala.concurrent.Await
import scala.concurrent.duration._
import scala.util.Success

/** *
  * This unit test suite has for objective to test the good functioning of the client and its compatibility with
  * the VSD REST API. Therefore, the code below should NOT be taken as an example usage of the client API, as it adds additional
  * complexity (and test framework specific code) to handle asynchronous events.
  * For a manual on the client API usage, please refer to our quick start document on Github as well as the API doc.
  */

class VSDTests extends FunSpec with ShouldMatchers with ScalaFutures {

  val vsd = VSDClient.demo("demo@virtualskeleton.ch", "demo").get

  implicit val system = vsd.system.dispatcher

  val tmpDir = new File(System.getProperty("java.io.tmpdir"))

  import VSDJson._

  private def recursiveDirDelete(dir: File): Unit = {
    if(dir.isDirectory){
      dir.listFiles().foreach{ f =>
        if(f.isDirectory) recursiveDirDelete(f) else f.delete
      }
    }
    dir.delete
  }


  describe("VSD REST connection") {

    val uploadedFile = scala.concurrent.Promise[VSDURL]


    it("can upload a single file") {
      println("sending file")
      val path = getClass().getResource("/dicomdir/1.2.840.113704.1.111.3216.1302961430.63764.dcm").getPath
      val r = vsd.uploadFile(new File(path), 5)

      whenReady(r, timeout(Span(1, Minutes))) { resp =>  uploadedFile.success(resp.file)}

    }

    it("can download a single file (previously uploaded)") {
      val fileurl = Await.result(uploadedFile.future, Duration(2, MINUTES))
      println("downloading file")
      val dldFile = vsd.downloadFile(fileurl, tmpDir, "Dummy")
      whenReady(dldFile, timeout(Span(1, Minutes))) { s => assert(s.exists); s.delete }
    }

    val uploadedObject = scala.concurrent.Promise[VSDURL]

    it("can upload a dicom directory ") {

      val path = getClass().getResource("/dicomdir/").getPath
      println("sending directory")
      val r = vsd.uploadDirectoryContent(new File(path))

      whenReady(r, timeout(Span(1, Minutes))) { s =>
        if (s.isLeft) {
          uploadedObject.failure(new Exception("Fail due to upload test fail"));
          fail(s"Sending dicom directory failed for ${s.left.map(_.size)} files")
        } else {
          s.right.map { ol =>
            val objid = ol.head
            uploadedObject.success(objid)
          }
        }
      }
      r onFailure {
        case s: ConnectionException => fail("Connection problem. This could be due to a self-signed certifcate. Please download the certificate from the VSD webserver and add it to the JVM's keychain")
      }
    }

    it("can download a vsd object (previously uploaded)") {
      val objId = Await.result(uploadedObject.future, Duration(5, MINUTES))
      println("downloading vsd object")
      val obj = vsd.downloadVSDObject(objId, tmpDir)
      whenReady(obj, timeout(Span(1, Minutes))) {s =>
        assert(s.exists)
        assert(s.isDirectory) // verify unzipping worked
        s.listFiles.map(_.delete)
        s.delete
      }
    }

    val objInfo = scala.concurrent.Promise[VSDRawImageObjectInfo]

    it("can retrieve information on a VSD Raw Image object") {
      val objId = Await.result(uploadedObject.future, Duration(5, MINUTES))
      println("retrieving object information")
      val info = vsd.getVSDObjectInfo[VSDRawImageObjectInfo](objId)
      whenReady(info, timeout(Span(1, Minutes))) { i =>
        objInfo.success(i)
        assert(i.rawImage.sliceThickness.get === 0.67f)
      }
      info onFailure {
        case e => objInfo.failure(new Exception("Failed to retrieve info to modifiy : " + e))
      }
    }

    it("can update information of a VSD object") {

      val newDescription = "Generated by unit test of VSDConnect REST client"
      val i = Await.result(objInfo.future, Duration(1, MINUTES))
      println("updating object information")
      val newInfo = i.copy(description = Some(newDescription))

      val f = for {
        f1 <- vsd.updateVSDObjectInfo(newInfo, 4)
        updatedInfo <- vsd.getVSDObjectInfo[VSDRawImageObjectInfo](VSDURL(i.selfUrl))
      } yield updatedInfo

      whenReady(f, timeout(Span(1, Minutes))) { s =>
        assert(s.rawImage.sliceThickness.get === 0.67f)
        assert(s.rawImage.sliceThickness.get === 0.67f)
        assert(s.description.get === newDescription)
      }
    }

    val ontologyKey = scala.concurrent.Promise[Int]

    it("can retrieve the list of ontologies") {
      println("listing ontologies")
      val ontologiesF = vsd.listOntologies
      whenReady(ontologiesF, timeout(Span(2, Minutes))) { o =>
        val l = o.types.find((v: VSDOntology) => v.value.equals("FMA"))
        assert(l.isDefined)
        l.map(t => ontologyKey.success(t.key))
        if (l.isEmpty) ontologyKey.failure(new Exception("Failed to retrieve the key of the FMA ontology"))
      }
    }

    val ontologyItem = scala.concurrent.Promise[VSDOntologyItem]
    val ontologyItem2 = scala.concurrent.Promise[VSDOntologyItem]

    it("can retrieve the list of ontology items for one given ontology") {
      val FMAtypeKey = Await.result(ontologyKey.future, Duration(1, MINUTES))
      println("retrieving ontology items")
      val listOntItems = vsd.listOntologyItemsForType(FMAtypeKey, 3)
      whenReady(listOntItems, timeout(Span(2, Minutes))) { l =>
        assert(l.length > 0)
        ontologyItem.success(l.head)
        ontologyItem2.success(l(1))
      }
      listOntItems onFailure { case e => ontologyItem.failure(new Exception("Failed to retrieve a valid ontology item id:  " + e)) }
    }

    val newObjInfo = scala.concurrent.Promise[VSDObjectInfo]
    val objOntoItemRelation = scala.concurrent.Promise[VSDObjectOntologyItem]

    it("can update the information of one object to be of a given ontology item") {
      val ontoItem = Await.result(ontologyItem.future, Duration(1, MINUTES))
      val oldObinf = Await.result(objInfo.future, Duration(1, MINUTES))
      println("updating object information to be of a certain ontology")
      val newObjOntoItemF = vsd.createObjectOntologyItemRelation(VSDURL(oldObinf.selfUrl), VSDURL(ontoItem.selfUrl))
      whenReady(newObjOntoItemF, timeout(Span(2, Minutes))) { newObjOntoItem =>
        assert(newObjOntoItem.position === oldObinf.ontologyItemRelations.map(_.items.size).getOrElse(0))
        objOntoItemRelation.success(newObjOntoItem)

        val f = vsd.getVSDObjectInfo[VSDRawImageObjectInfo](VSDURL(oldObinf.selfUrl))
        f onSuccess { case i => newObjInfo.success(i) }
        f onFailure { case e => newObjInfo.failure(new Exception("Failed to fetch obj Info after adding ontology item " + e)) }
      }
      newObjOntoItemF onFailure {
        case e =>
          newObjInfo.failure(new Exception("Failed to create first ontology relation " + e))
          objOntoItemRelation.failure(new Exception("Failed to create first ontology relation " + e))
      }
    }

    val readyToCleanObject = scala.concurrent.Promise[Boolean]
    val readyToCleanFolder = scala.concurrent.Promise[Boolean]

    it("can update an object ontology relation") {
      val ontoItem = Await.result(ontologyItem2.future, Duration(1, MINUTES))
      val objOntoItemRel = Await.result(objOntoItemRelation.future, Duration(1, MINUTES))

      val newInfo = Await.result(newObjInfo.future, Duration(1, MINUTES))
      println("updating object ontology relation")
      val secondObjItemF = vsd.updateObjectOntologyItemRelation(objOntoItemRel, newInfo, VSDURL(ontoItem.selfUrl))

      whenReady(secondObjItemF, timeout(Span(2, Minutes))) { newObjOntoItem =>
        assert(newObjOntoItem.ontologyItem.selfUrl === ontoItem.selfUrl)
      }
    }

    it("uploaded object appears in list of unpublished objects") {
      val info = Await.result(objInfo.future, Duration(1, MINUTES))
      println("checking that uploaded object appears in list")
      val unpublishedF = vsd.listUnpublishedObjects(3)       
      val t = unpublishedF.map(l => l.map(_.id).contains (info.id))
      whenReady(t, timeout(Span(1, Minutes))) { v =>  assert(v)   }
    }


//    it("can list published objects") {
//      val l = vsd.listPublishedObjects()
//      whenReady(l, timeout(Span(1, Minutes))) { v =>   assert(v.size > 0) }
//    }


    val myDatafolder = scala.concurrent.Promise[VSDFolder]

    it("can list available folders") {
      val dirs = vsd.listFolders()
      whenReady(dirs, timeout(Span(1, Minutes))) { r =>
        assert(r.size > 0)
        r.find(i => i.level==1 && i.name == "MyProjects").map { myDatafolder.success(_) }
      }
    }

    val myCreatedfolder = scala.concurrent.Promise[VSDFolder]

    it("can create a folder") {
      println("creating folder")
      val parentFolder = Await.result(myDatafolder.future, Duration(1, MINUTES))
      val folderInfo = vsd.createFolder("unitTestFolder", VSDURL(parentFolder.selfUrl))
      whenReady(folderInfo, timeout(Span(1, Minutes))) { i =>
        assert(i.name === "unitTestFolder")
        myCreatedfolder.success(i)
      }
    }

    it("can retrieve correct info given a folder id") {
      val createdInfo = Await.result(myCreatedfolder.future, Duration(1, MINUTES))
      val queriedInfo = vsd.getFolderInfo(VSDURL(createdInfo.selfUrl))
      whenReady(queriedInfo, timeout(Span(1, Minutes))) { i =>
        assert(i.selfUrl === createdInfo.selfUrl && i.name ==="unitTestFolder")
      }
    }

    val addedToFolder = scala.concurrent.Promise[VSDFolder]

    it("can add an object to a folder") {
      val createdInfo = Await.result(myCreatedfolder.future, Duration(1, MINUTES))
      val info = Await.result(objInfo.future, Duration(1, MINUTES))

      val u = vsd.addObjectToFolder(VSDURL(info.selfUrl), createdInfo)
      whenReady(u, timeout(Span(1, Minutes))) { f =>
        assert(f.containedObjects.get.contains(VSDURL(info.selfUrl)))
        addedToFolder.success(f)
      }
    }

    it("can download the content of a folder") {
      val folderInf = Await.result(addedToFolder.future, Duration(1, MINUTES))
      val info = Await.result(objInfo.future, Duration(1, MINUTES))

      val dest = File.createTempFile("UnitTestVSDFolder_" + folderInf.id, "")
      val r = vsd.downloadFolder(folderInf, dest)

      whenReady(r, timeout(Span(4, Minutes))) { f =>

        assert(f(0)._1.id === info.id)
        val fil = new File(f(0)._2.getAbsolutePath)
        assert(fil.exists())

        // clean up directory
        recursiveDirDelete(f(0)._2.getParentFile)
        assert(true)
      }
    }


    it("can remove an object from a folder") {
      val addedInfo = Await.result(addedToFolder.future, Duration(1, MINUTES))
      val info = Await.result(objInfo.future, Duration(1, MINUTES))

      val u = vsd.removeObjectFromFolder(VSDURL(info.selfUrl), addedInfo)
      whenReady(u, timeout(Span(1, Minutes))) { f =>
        assert(f.containedObjects.getOrElse(Seq[VSDURL]()).find(_ == VSDURL(info.selfUrl)) isEmpty)
      }
    }


    it("can retrieve the hierarchical path of a folder") {
      val addedInfo = Await.result(addedToFolder.future, Duration(1, MINUTES))
      val u = vsd.getFolderPath(VSDURL(addedInfo.selfUrl))

      whenReady(u, timeout(Span(1, Minutes))) { p => assert(p == "/demo/MyProjects/unitTestFolder") }
    }


    it("can retrieve a folder from its hierarchical path") {
      val addedInfo = Await.result(addedToFolder.future, Duration(1, MINUTES))
      val folderF = vsd.getFolderFromPath( "/demo/MyProjects/unitTestFolder")
      whenReady(folderF, timeout(Span(1, Minutes))) { folder =>
        assert(folder.isDefined && folder.get.id == addedInfo.id)
      }
    }


    val object2P = scala.concurrent.Promise[VSDURL]

    it("can upload a nifti segmentation") {
      val obj1Info = Await.result(objInfo.future, Duration(1, MINUTES))
      val path = getClass().getResource("/volume.nii").getPath
      val idObj2F = vsd.uploadFile(new File(path), 20).map { t => t.relatedObject}
      whenReady(idObj2F, timeout(Span(2, Minutes))) { idObj2 =>
        object2P.success(idObj2)
      }
    }

    val linkP = scala.concurrent.Promise[VSDLink]

    it("can link 2 objects") {
      // first upload a second object
      val obj1Info = Await.result(objInfo.future, Duration(1, MINUTES))
      val obj2Id = Await.result(object2P.future, Duration(3, MINUTES))

      val fut = for {
        obj2Info <- vsd.getVSDObjectInfo[VSDCommonObjectInfo](obj2Id)
        link <- vsd.addLink(VSDURL(obj2Info.selfUrl), VSDURL(obj1Info.selfUrl))
        lookedUpLink <- vsd.getLinkInfo(VSDURL(link.selfUrl))
      } yield {(lookedUpLink,obj2Info)}

      whenReady(fut, timeout(Span(4, Minutes))) { case (link, obj2) =>
        assert(link.object1.selfUrl == obj2.selfUrl  && link.object2.selfUrl == obj1Info.selfUrl)
        linkP.success(link)
      }
    }

    it("can list the modalities on the VSD") {
      val modalitiesF = vsd.listModalities()
      whenReady(modalitiesF, timeout(Span(1, Minutes))) { modalities =>
         assert(modalities.find(_.name == "CT").isDefined)
      }
    }

    it("can list the segmentation methods supported by the VSD") {
      val segMethsF = vsd.listSegmentationMethods()
      whenReady(segMethsF, timeout(Span(1, Minutes))) { segMethods =>
        assert(segMethods.find(_.name == "Manual").isDefined)
      }
    }

    it("can upload a statistical model and have it recognized as such") {
      val path = getClass().getResource("/torus.h5").getPath
      val f = for {
        s <- vsd.uploadFile(new File(path),5).map { t => t.relatedObject}
        i <- vsd.getVSDObjectInfo[VSDStatisticalModelObjectInfo](s)
      } yield i

      whenReady(f, timeout(Span(2, Minutes))) { info =>
        assert(info.`type`.name == VSDStatisticalModelObjectType.name)
        // delete it immediately
        vsd.deleteUnpublishedVSDObject(VSDURL(info.selfUrl))
      }
    }

    it("can assign object group right") {
      val obj1Info = Await.result(objInfo.future, Duration(1, MINUTES))

      val rightF = for {
        group <- vsd.listGroups.map(_.head)
        r <- vsd.setObjectGroupRights(VSDURL(obj1Info.selfUrl), VSDURL(group.selfUrl), Seq(VSDVisitRight))
      } yield r

      whenReady(rightF, timeout(Span(2, Minutes))) { right =>
        assert(right.relatedRights(0).selfUrl == VSDVisitRight.selfUrl)
      }
    }


    val rightP = scala.concurrent.Promise[VSDObjectUserRight]
    it("can assign object user rights") {
      val obj1Info = Await.result(objInfo.future, Duration(1, MINUTES))

      val rightF = for {
        user <- vsd.getUserInfo(VSDURL("https://demo.virtualskeleton.ch/api/users/1"))
        r <- vsd.setObjectUserRights(VSDURL(obj1Info.selfUrl), VSDURL(user.selfUrl), Seq(VSDVisitRight))
      } yield r

      whenReady(rightF, timeout(Span(2, Minutes))) { right =>
        assert(right.relatedRights(0).selfUrl == VSDVisitRight.selfUrl)
        rightP.success(right)
        readyToCleanObject.complete(Success(true))
      }
    }

    it("can retrieve object user rights") {
      val right = Await.result(rightP.future, Duration(5, MINUTES))
      val readRightF = vsd.getObjectUserRight(VSDURL(right.selfUrl))
      whenReady(readRightF, timeout(Span(2, Minutes))) { readRight =>
        assert(readRight == right)
      }
    }

    it("can delete a link") {
      val link = Await.result(linkP.future, Duration(5, MINUTES))
      val del = vsd.deleteLink(VSDURL(link.selfUrl))
      whenReady(del, timeout(Span(1, Minutes))) { u => assert(u.isSuccess) }
    }

    it("can delete unpublished VSD objects") {
      val objId = Await.result(uploadedObject.future, Duration(5, MINUTES))
      val obj2Id = Await.result(object2P.future, Duration(5, MINUTES))
      // Wait until all other tests finished
      Await.result(readyToCleanObject.future, Duration(6, MINUTES))

      val d = for {
        a <- vsd.deleteUnpublishedVSDObject(objId)
        b <- vsd.deleteUnpublishedVSDObject(obj2Id)
      } yield b

      whenReady(d, timeout(Span(1, Minutes))) { r =>
        assert(r.isSuccess)
        readyToCleanFolder.success(true)
      }
    }

    it("can delete an empty folder") {
      val createdInfo = Await.result(myCreatedfolder.future, Duration(1, MINUTES))
      //  Await.result(readyToCleanFolder.future, Duration(6, MINUTES))

      val deletion = vsd.deleteFolder(VSDURL(createdInfo.selfUrl))
      whenReady(deletion, timeout(Span(1, Minutes))) { r => assert(r.isSuccess) }
    }

  }

}